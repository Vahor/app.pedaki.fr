// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")

  relationMode = "prisma"
}

// Necessary for Next auth
model Account {
  id                String  @id @default(cuid()) @db.VarChar(25)
  userId            String  @map("user_id") @db.VarChar(25)
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model User {
  id            String    @id @default(cuid()) @db.VarChar(25)
  name          String
  email         String    @unique
  emailVerified DateTime? @map("email_verified")
  password      String?

  image String @default("") @db.VarChar(1000)

  accounts    Account[]
  tokens      Token[]
  memberships WorkspaceMember[]

  @@index([id])
  @@map("users")
}

model Token {
  id String @id @default(cuid()) @db.VarChar(25)

  createdAt   DateTime  @default(now()) @map("created_at")
  type        TokenType
  hashedToken String    @map("hashed_token")
  expiresAt   DateTime  @map("expires_at")

  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String? @map("user_id") @db.VarChar(25)

  invitation WorkspaceInvitation?

  @@unique([type, hashedToken], name: "unique_token")
  @@index([userId])
  @@map("tokens")
}

enum TokenType {
  CONFIRM_EMAIL
  WORKSPACE_INVITATION
}

model Workspace {
  id        String   @id @default(cuid()) @db.VarChar(25)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  name String @db.VarChar(100)

  // Used as slug, then as subdomain when the workspace is created
  identifier String @unique @db.VarChar(60)

  members     WorkspaceMember[]
  invitations WorkspaceInvitation[]
  settings    WorkspaceSetting[]

  subscriptions WorkspaceSubscription[]

  @@index([id])
  @@map("workspaces")
}

// To get the current subscription, we can just get the one with the latest paidUntil date
model WorkspaceSubscription {
  id        String   @id @default(cuid()) @db.VarChar(25)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  // Type can be "extra_support", "scaler" etc.
  // This type should map to a product on our code
  // and in our code we map it to a stripe product
  type String

  paidUntil DateTime            @map("paid_until")
  resources WorkspaceResource[]

  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  workspaceId String    @db.VarChar(25)

  receipt   WorkspaceSubscriptionReceipt @relation(fields: [receiptId], references: [id])
  receiptId String                       @unique @map("receipt_id") @db.VarChar(25)

  @@index([workspaceId])
  @@index([receiptId])
  @@map("workspace_subscriptions")
}

model WorkspaceSubscriptionReceipt {
  id        String   @id @default(cuid()) @db.VarChar(25)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  // If the payment failed, we'll still have a receipt, but no subscription
  subscription WorkspaceSubscription?

  // TODO: improve the schema to add the price, status etc
  //    I can't to it now as I don't know the structure of the data
  data Json

  @@map("workspace_subscription_receipts")
}

// The invitation is expired if the token is expired
// After a long time, the token is automatically deleted, and the invitation is deleted with it
// When the invitation is accepted we can delete the token only, this will delete the invitation as well
model WorkspaceInvitation {
  id        String   @id @default(cuid()) @db.VarChar(25)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  email       String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId String    @map("workspace_id") @db.VarChar(25)

  token   Token  @relation(fields: [tokenId], references: [id], onDelete: Cascade)
  tokenId String @unique @map("token_id") @db.VarChar(25)

  @@index([workspaceId])
  @@map("workspace_invitations")
}

// Each workspace has a set of roles
// When the workspace is created we populate the roles with the default roles
model WorkspaceRole {
  id        String   @id @default(cuid()) @db.VarChar(25)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  name        String  @db.VarChar(100)
  description String?
  // As the role can be randmed we cant use the name as the identifier
  // So we have to add a is_admin field
  // This field is only used for the seeding, and is not used in the code
  isAdmin     Boolean @default(false) @map("is_admin")

  workspaceId String @map("workspace_id") @db.VarChar(25)

  permissions WorkspacePermission[]
  memberRoles WorkspaceMemberRole[]

  @@unique([name, workspaceId])
  @@index([workspaceId])
  @@map("workspace_roles")
}

// The permissions are common across all workspaces
model WorkspacePermission {
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  identifier String @id @db.VarChar(100)

  roles WorkspaceRole[]

  @@map("workspace_permissions")
}

model WorkspaceMember {
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  roles  WorkspaceMemberRole[]
  user   User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String                @map("user_id") @db.VarChar(25)

  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId String    @map("workspace_id") @db.VarChar(25)

  @@id([userId, workspaceId])
  @@index([workspaceId])
  @@index([userId])
  @@map("workspace_members")
}

model WorkspaceMemberRole {
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  role   WorkspaceRole @relation(fields: [roleId], references: [id])
  roleId String        @map("role_id") @db.VarChar(25)

  member   WorkspaceMember @relation(fields: [memberId, workspaceId], references: [userId, workspaceId], onDelete: Cascade)
  memberId String          @map("member_id") @db.VarChar(25)

  workspaceId String @map("workspace_id") @db.VarChar(25)

  @@unique([roleId, memberId])
  @@index([memberId, workspaceId])
  @@map("workspace_member_to_workspace_roles")
}

// AKA Server / Database etc
model WorkspaceResource {
  id        String   @id @default(cuid()) @db.VarChar(25)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  region   String @db.VarChar(25)
  provider String @db.VarChar(25)
  type     String @db.VarChar(25)

  identifier String // aws arm etc

  data Json // As we can't know the structure of the data, we'll just store it as a json blob. We'll have to parse it knowing the type,region,provider etc

  subscription   WorkspaceSubscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?                @db.VarChar(25)

  @@index([subscriptionId])
  @@map("workspace_resources")
}

// ex: auto_renew, default_region
model WorkspaceSetting {
  id        String   @id @default(cuid()) @db.VarChar(25)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  key   String
  value String

  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId String    @map("workspace_id") @db.VarChar(25)

  @@unique([key, workspaceId])
  @@index([workspaceId])
  @@map("workspace_settings")
}
