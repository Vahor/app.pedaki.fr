// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")

  relationMode = "prisma"
}

model Workspace {
  id        String   @id @default(cuid()) @db.VarChar(25)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  name String @db.VarChar(100)

  // Date when a workspace was deleted
  // We keep it in our database for 10 years
  // So we can still download the subscription receipts
  deletedAt DateTime? @map("deleted_at")

  // Used as subdomain when the workspace is created
  // An identifier is null if the workspaces was deleted (as we need it to be unique)
  identifier String? @unique @db.VarChar(60)

  // The user responsible for the workspace
  mainEmail String @map("main_email") @db.VarChar(320)

  members WorkspaceMember[]

  subscriptions WorkspaceSubscription[]
  quotas        CustomQuotas[]
  settings      WorkspaceSetting[]
  token         WorkspaceToken?

  @@index([id])
  @@map("workspace")
}

model WorkspaceToken {
  id Int @id @default(autoincrement())

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  token     String  @unique /// @encrypted
  tokenHash   String?    @unique @map("token_hash") /// @encryption:hash(token)

  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId String    @unique @map("workspace_id") @db.VarChar(25)

  @@index([workspaceId])
  @@map("token_to_workspace")
}

// To get the current subscription, we can just get the one with the latest paidUntil date
model WorkspaceSubscription {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  // Type can be "extra_support", "scaler" etc.
  // This type should map to a product on our code
  // and in our code we map it to a stripe product
  type String

  paidUntil DateTime            @map("paid_until")
  resources WorkspaceResource[]

  workspace   Workspace @relation(fields: [workspaceId], references: [id])
  workspaceId String    @db.VarChar(25)

  receipt   WorkspaceSubscriptionReceipt @relation(fields: [receiptId], references: [id])
  receiptId Int                          @unique @map("receipt_id")

  @@index([workspaceId])
  @@index([receiptId])
  @@map("workspace_subscriptions")
}

model WorkspaceSubscriptionReceipt {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  // If the payment failed, we'll still have a receipt, but no subscription
  subscription WorkspaceSubscription?

  // TODO: improve the schema to add the price, status etc
  //    I can't to it now as I don't know the structure of the data
  data Json

  @@map("workspace_subscription_receipts")
}

model WorkspaceMember {
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @map("updated_at")

  email String @db.VarChar(320)

  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId String    @map("workspace_id") @db.VarChar(25)

  @@id([email, workspaceId])
  @@index([workspaceId])
  @@index([email])
  @@map("workspace_members")
}

// AKA Server / Database etc
model WorkspaceResource {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  region   String @db.VarChar(25)
  provider String @db.VarChar(25)
  type     String @db.VarChar(25)

  identifier String // aws arm etc

  data Json // As we can't know the structure of the data, we'll just store it as a json blob. We'll have to parse it knowing the type,region,provider etc

  subscription   WorkspaceSubscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId Int?

  @@index([subscriptionId])
  @@map("workspace_resources")
}

// ex: auto_renew, default_region
model WorkspaceSetting {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  key   String
  value String

  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId String    @map("workspace_id") @db.VarChar(25)

  @@unique([key, workspaceId])
  @@index([workspaceId])
  @@map("workspace_settings")
}

model CustomQuotas {
  key   String @id @db.VarChar(100)
  value Int    @db.Int

  wokspace    Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  workspaceId String?    @map("workspace_id") @db.VarChar(25)

  email String? @map("email") @db.VarChar(320)

  @@unique([key, workspaceId])
  @@unique([key, email])
  @@index([workspaceId])
  @@index([email])
  @@map("custom_quotas")
}
